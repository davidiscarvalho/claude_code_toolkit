#!/bin/bash
# zk - Zettelkasten Brain CLI for Claude Code
# Token-efficient personal knowledge base using SQLite
# Version: 1.2.0

set -e

ZK_DIR="${ZK_DIR:-$HOME/.claude/zk_brain}"
DB_FILE="$ZK_DIR/brain.db"

# Colors for output (disabled if not tty)
if [ -t 1 ]; then
    BOLD='\033[1m'
    DIM='\033[2m'
    RESET='\033[0m'
    CYAN='\033[36m'
    GREEN='\033[32m'
    YELLOW='\033[33m'
    RED='\033[31m'
else
    BOLD='' DIM='' RESET='' CYAN='' GREEN='' YELLOW='' RED=''
fi

# Check dependencies on first run
check_dependencies() {
    local missing=()

    if ! command -v sqlite3 &> /dev/null; then
        missing+=("sqlite3")
    fi

    if ! command -v jq &> /dev/null; then
        missing+=("jq")
    fi

    if [ ${#missing[@]} -gt 0 ]; then
        echo -e "${RED}Error: Missing required dependencies: ${missing[*]}${RESET}" >&2
        echo "" >&2
        echo "Install with:" >&2
        echo "  Ubuntu/Debian: sudo apt install ${missing[*]}" >&2
        echo "  macOS:         brew install ${missing[*]}" >&2
        echo "  Arch:          sudo pacman -S ${missing[*]}" >&2
        exit 1
    fi
}

# SQL escape function - handles single quotes and backslashes
sql_escape() {
    # Replace single quotes with two single quotes (SQL standard)
    # This handles cases like: O'Reilly -> O''Reilly
    echo "${1//\'/\'\'}"
}

# Validate ID is a positive integer
validate_id() {
    if ! [[ "$1" =~ ^[0-9]+$ ]]; then
        echo -e "${RED}Error: Invalid ID '$1' - must be a positive integer${RESET}" >&2
        return 1
    fi
}

# Check if note exists
note_exists() {
    local id="$1"
    local count
    count=$(sqlite3 "$DB_FILE" "SELECT COUNT(*) FROM notes WHERE id = $id;")
    [ "$count" -gt 0 ]
}

# Initialize database
init_db() {
    check_dependencies
    mkdir -p "$ZK_DIR"
    sqlite3 "$DB_FILE" <<'SQL'
CREATE TABLE IF NOT EXISTS notes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    tags TEXT DEFAULT '',
    project TEXT DEFAULT NULL,
    related_ids TEXT DEFAULT '',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    archived_at DATETIME DEFAULT NULL
);

CREATE INDEX IF NOT EXISTS idx_notes_tags ON notes(tags);
CREATE INDEX IF NOT EXISTS idx_notes_project ON notes(project);
CREATE INDEX IF NOT EXISTS idx_notes_archived ON notes(archived_at);

CREATE VIRTUAL TABLE IF NOT EXISTS notes_fts USING fts5(
    title, content, tags,
    content='notes',
    content_rowid='id'
);

-- Triggers to keep FTS in sync
CREATE TRIGGER IF NOT EXISTS notes_ai AFTER INSERT ON notes BEGIN
    INSERT INTO notes_fts(rowid, title, content, tags) VALUES (new.id, new.title, new.content, new.tags);
END;

CREATE TRIGGER IF NOT EXISTS notes_ad AFTER DELETE ON notes BEGIN
    INSERT INTO notes_fts(notes_fts, rowid, title, content, tags) VALUES('delete', old.id, old.title, old.content, old.tags);
END;

CREATE TRIGGER IF NOT EXISTS notes_au AFTER UPDATE ON notes BEGIN
    INSERT INTO notes_fts(notes_fts, rowid, title, content, tags) VALUES('delete', old.id, old.title, old.content, old.tags);
    INSERT INTO notes_fts(rowid, title, content, tags) VALUES (new.id, new.title, new.content, new.tags);
END;
SQL
    echo "Initialized zk_brain at $ZK_DIR"
}

# Ensure DB exists
ensure_db() {
    check_dependencies
    if [ ! -f "$DB_FILE" ]; then
        init_db >/dev/null
    fi
}

# Upgrade database schema (for v1.1.0 -> v1.2.0)
upgrade_db() {
    ensure_db
    # Check if related_ids column exists
    local has_column
    has_column=$(sqlite3 "$DB_FILE" "PRAGMA table_info(notes);" | grep -c "related_ids" || true)

    if [ "$has_column" -eq 0 ]; then
        echo "Upgrading database schema to v1.2.0..."
        sqlite3 "$DB_FILE" "ALTER TABLE notes ADD COLUMN related_ids TEXT DEFAULT '';"
        echo "âœ“ Database upgraded successfully"
    else
        echo "Database is already at v1.2.0 or later"
    fi
}

# Get current project from git or directory name
get_current_project() {
    local proj
    proj=$(git rev-parse --show-toplevel 2>/dev/null | xargs basename 2>/dev/null) || proj=$(basename "$(pwd)")
    echo "$proj"
}

# Add related ID (maintains uniqueness, no duplicates)
add_related_id() {
    local note_id="$1"
    local related_id="$2"

    # Get current related_ids
    local current
    current=$(sqlite3 "$DB_FILE" "SELECT related_ids FROM notes WHERE id = $note_id;")

    # Check if already present
    if echo ",$current," | grep -q ",$related_id,"; then
        return 0  # Already linked
    fi

    # Add the new ID
    if [ -n "$current" ]; then
        current="$current,$related_id"
    else
        current="$related_id"
    fi

    sqlite3 "$DB_FILE" "UPDATE notes SET related_ids = '$current' WHERE id = $note_id;"
}

# Remove related ID
remove_related_id() {
    local note_id="$1"
    local related_id="$2"

    local current
    current=$(sqlite3 "$DB_FILE" "SELECT related_ids FROM notes WHERE id = $note_id;")

    # Remove the ID using sed
    local updated
    updated=$(echo "$current" | sed "s/^$related_id,//; s/,$related_id,/,/g; s/,$related_id$//; s/^$related_id$//")

    sqlite3 "$DB_FILE" "UPDATE notes SET related_ids = '$updated' WHERE id = $note_id;"
}

# Get related notes as array
get_related_ids() {
    local note_id="$1"
    local related_ids
    related_ids=$(sqlite3 "$DB_FILE" "SELECT related_ids FROM notes WHERE id = $note_id;")

    if [ -n "$related_ids" ]; then
        echo "$related_ids"
    fi
}

# Usage/help
usage() {
    cat <<'EOF'
zk - Zettelkasten Brain CLI (v1.2.0)

SEARCH (cheap - returns IDs + titles only, ~50 tokens):
  zk search "query"              Search all active notes
  zk search -p PROJECT "query"   Search within project (use -p . for current)
  zk search -a "query"           Include archived notes
  zk search -t TAG "query"       Filter by tag

RETRIEVE (fetch full content when needed):
  zk get ID                      Get full note by ID (shows related notes)
  zk get ID ID2 ...              Get multiple notes

ADD/UPDATE:
  zk add "title" "tags" "content"           Add global note
  zk add -p PROJECT "title" "tags" "content"  Add to project (-p . for current)
  zk update ID "new content"                Update note content
  zk update ID -t "new,tags"                Update tags
  zk update ID -T "new title"               Update title

LINK NOTES (knowledge graphs):
  zk link ID1 ID2                Link two notes (bidirectional)
  zk unlink ID1 ID2              Remove link between notes
  zk related ID                  List related notes (minimal)
  zk related ID --full           Get full content of all related notes

LIST (minimal output):
  zk list                        List all active notes (id, title, project)
  zk list -p PROJECT             List project notes (-p . for current)
  zk list -t TAG                 List by tag
  zk list -a                     Include archived

ORGANIZE:
  zk tags                        List all tags with counts
  zk projects                    List all projects with counts
  zk archive ID                  Archive a note
  zk unarchive ID                Restore archived note
  zk delete ID                   Permanently delete note

BULK OPERATIONS:
  zk feed FILE                   Analyze file, suggest atomic notes (interactive)
  zk import FILE                 Import notes from JSON/JSONL
  zk export [FILE]               Export all notes to JSON
  zk stats                       Show database statistics

MAINTENANCE:
  zk init                        Initialize/reset database
  zk upgrade                     Upgrade database schema (v1.1.0 -> v1.2.0)
  zk vacuum                      Optimize database
  zk backup [FILE]               Backup database

Examples:
  zk search "authentication pattern"
  zk add "Clerk redirect fix" "auth,clerk,bug" "After user creation, use..."
  zk add -p . "API rate limits" "api,limits" "Current limits: 100/min"
  zk get 42
  zk link 42 43                  # Link decision to implementation
  zk related 42                  # Show all notes related to #42
  zk list -p myproject
EOF
}

# Search notes - returns minimal info for token efficiency
cmd_search() {
    ensure_db
    local project="" include_archived=0 tag=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p|--project)
                project="$2"
                [ "$project" = "." ] && project=$(get_current_project)
                shift 2
                ;;
            -a|--archived)
                include_archived=1
                shift
                ;;
            -t|--tag)
                tag="$2"
                shift 2
                ;;
            *)
                break
                ;;
        esac
    done

    local query="$*"
    if [ -z "$query" ]; then
        echo "Usage: zk search [-p project] [-a] [-t tag] \"query\""
        return 1
    fi

    # Build WHERE clause with proper escaping
    local where_clause="archived_at IS NULL"
    [ "$include_archived" = "1" ] && where_clause="1=1"

    if [ -n "$project" ]; then
        local escaped_project
        escaped_project=$(sql_escape "$project")
        where_clause="$where_clause AND project = '$escaped_project'"
    fi

    if [ -n "$tag" ]; then
        local escaped_tag
        escaped_tag=$(sql_escape "$tag")
        where_clause="$where_clause AND tags LIKE '%$escaped_tag%'"
    fi

    # Convert query to FTS5 format (OR between words)
    # Remove special chars that could break FTS5 syntax
    local fts_query
    fts_query=$(echo "$query" | sed 's/[[:space:]]\+/ OR /g; s/[^a-zA-Z0-9_ OR]//g')

    if [ -z "$fts_query" ]; then
        echo -e "${RED}Error: Search query contains no valid search terms${RESET}" >&2
        return 1
    fi

    # FTS search with snippet for context
    local results
    results=$(sqlite3 -separator '|' "$DB_FILE" <<SQL
SELECT n.id, n.title, n.tags, COALESCE(n.project, 'global'),
       snippet(notes_fts, 1, '>>>', '<<<', '...', 20) as excerpt
FROM notes_fts f
JOIN notes n ON n.id = f.rowid
WHERE notes_fts MATCH '$fts_query' AND $where_clause
ORDER BY rank
LIMIT 20;
SQL
)

    if [ -z "$results" ]; then
        echo -e "${YELLOW}No results found for: $query${RESET}" >&2
        return 0
    fi

    echo "$results"
}

# Get full note(s)
cmd_get() {
    ensure_db
    if [ $# -eq 0 ]; then
        echo "Usage: zk get ID [ID2 ...]"
        return 1
    fi

    for id in "$@"; do
        validate_id "$id" || continue

        if ! note_exists "$id"; then
            echo -e "${RED}Error: Note #$id not found${RESET}" >&2
            continue
        fi

        sqlite3 -separator '|' "$DB_FILE" <<SQL
SELECT '---', id, title, tags, COALESCE(project, 'global'),
       datetime(created_at), datetime(updated_at),
       CASE WHEN archived_at IS NOT NULL THEN 'ARCHIVED' ELSE 'active' END
FROM notes WHERE id = $id;
SELECT content FROM notes WHERE id = $id;
SQL

        # Show related notes if any
        local related_ids
        related_ids=$(get_related_ids "$id")

        if [ -n "$related_ids" ]; then
            echo "---"
            echo -e "${CYAN}Related notes:${RESET}"

            # Convert comma-separated IDs to array and fetch titles
            IFS=',' read -ra IDS <<< "$related_ids"
            for rid in "${IDS[@]}"; do
                if note_exists "$rid"; then
                    local related_info
                    related_info=$(sqlite3 -separator '|' "$DB_FILE" "SELECT id, title, tags FROM notes WHERE id = $rid;")
                    echo "  #$related_info"
                fi
            done
        fi

        # Show suggested links (notes with similar tags or same project)
        local note_tags note_project
        note_tags=$(sqlite3 "$DB_FILE" "SELECT tags FROM notes WHERE id = $id;")
        note_project=$(sqlite3 "$DB_FILE" "SELECT project FROM notes WHERE id = $id;")

        # Build exclusion list (current note + already linked notes)
        local exclude_ids="$id"
        if [ -n "$related_ids" ]; then
            exclude_ids="$id,$related_ids"
        fi

        # Find suggested notes (limit to 3 for token efficiency)
        local suggestions=""
        if [ -n "$note_tags" ]; then
            # Convert tags to SQL pattern matching
            local tag_patterns=""
            IFS=',' read -ra TAGS <<< "$note_tags"
            for tag in "${TAGS[@]}"; do
                if [ -n "$tag_patterns" ]; then
                    tag_patterns="$tag_patterns OR tags LIKE '%$tag%'"
                else
                    tag_patterns="tags LIKE '%$tag%'"
                fi
            done

            # Find notes with overlapping tags
            suggestions=$(sqlite3 -separator '|' "$DB_FILE" <<SQL
SELECT id, title, 'similar tags' as reason
FROM notes
WHERE ($tag_patterns)
  AND id NOT IN ($exclude_ids)
  AND archived_at IS NULL
ORDER BY updated_at DESC
LIMIT 3;
SQL
)
        fi

        # Add same-project suggestions if no tag-based suggestions
        if [ -z "$suggestions" ] && [ -n "$note_project" ] && [ "$note_project" != "NULL" ]; then
            suggestions=$(sqlite3 -separator '|' "$DB_FILE" <<SQL
SELECT id, title, 'same project' as reason
FROM notes
WHERE project = '$note_project'
  AND id NOT IN ($exclude_ids)
  AND archived_at IS NULL
ORDER BY updated_at DESC
LIMIT 3;
SQL
)
        fi

        if [ -n "$suggestions" ]; then
            echo "---"
            echo -e "${DIM}ðŸ’¡ Suggested links:${RESET}"
            echo "$suggestions" | while IFS='|' read -r sid stitle sreason; do
                echo -e "  ${DIM}#$sid $stitle ($sreason)${RESET}"
            done
        fi

        echo "---"
    done
}

# Add a note
cmd_add() {
    ensure_db
    local project=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p|--project)
                project="$2"
                [ "$project" = "." ] && project=$(get_current_project)
                shift 2
                ;;
            *)
                break
                ;;
        esac
    done

    if [ $# -lt 3 ]; then
        echo "Usage: zk add [-p project] \"title\" \"tags\" \"content\""
        return 1
    fi

    local title="$1" tags="$2" content="$3"

    # Escape for SQL
    title=$(sql_escape "$title")
    tags=$(sql_escape "$tags")
    content=$(sql_escape "$content")

    local proj_sql="NULL"
    if [ -n "$project" ]; then
        local escaped_project
        escaped_project=$(sql_escape "$project")
        proj_sql="'$escaped_project'"
    fi

    local new_id
    new_id=$(sqlite3 "$DB_FILE" <<SQL
INSERT INTO notes (title, tags, content, project) VALUES ('$title', '$tags', '$content', $proj_sql);
SELECT last_insert_rowid();
SQL
)
    echo "Added note #$new_id: $title"
}

# Update a note
cmd_update() {
    ensure_db
    if [ $# -lt 2 ]; then
        echo "Usage: zk update ID \"new content\" | -t \"new,tags\" | -T \"new title\""
        return 1
    fi

    local id="$1"
    validate_id "$id" || return 1

    if ! note_exists "$id"; then
        echo -e "${RED}Error: Note #$id not found${RESET}" >&2
        return 1
    fi

    shift

    case "$1" in
        -t|--tags)
            local tags
            tags=$(sql_escape "$2")
            sqlite3 "$DB_FILE" "UPDATE notes SET tags = '$tags', updated_at = CURRENT_TIMESTAMP WHERE id = $id;"
            echo "Updated tags for note #$id"
            ;;
        -T|--title)
            local title
            title=$(sql_escape "$2")
            sqlite3 "$DB_FILE" "UPDATE notes SET title = '$title', updated_at = CURRENT_TIMESTAMP WHERE id = $id;"
            echo "Updated title for note #$id"
            ;;
        *)
            local content
            content=$(sql_escape "$*")
            sqlite3 "$DB_FILE" "UPDATE notes SET content = '$content', updated_at = CURRENT_TIMESTAMP WHERE id = $id;"
            echo "Updated content for note #$id"
            ;;
    esac
}

# List notes (minimal output)
cmd_list() {
    ensure_db
    local project="" include_archived=0 tag="" limit=50

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p|--project)
                project="$2"
                [ "$project" = "." ] && project=$(get_current_project)
                shift 2
                ;;
            -a|--archived)
                include_archived=1
                shift
                ;;
            -t|--tag)
                tag="$2"
                shift 2
                ;;
            -n|--limit)
                limit="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    local where_clause="archived_at IS NULL"
    [ "$include_archived" = "1" ] && where_clause="1=1"

    if [ -n "$project" ]; then
        local escaped_project
        escaped_project=$(sql_escape "$project")
        where_clause="$where_clause AND project = '$escaped_project'"
    fi

    if [ -n "$tag" ]; then
        local escaped_tag
        escaped_tag=$(sql_escape "$tag")
        where_clause="$where_clause AND tags LIKE '%$escaped_tag%'"
    fi

    sqlite3 -separator '|' "$DB_FILE" <<SQL
SELECT id, title, tags, COALESCE(project, 'global'),
       CASE
           WHEN related_ids != '' THEN
               '[' || (LENGTH(related_ids) - LENGTH(REPLACE(related_ids, ',', '')) + 1) || ']'
           ELSE ''
       END as links
FROM notes
WHERE $where_clause
ORDER BY updated_at DESC
LIMIT $limit;
SQL
}

# List all tags with counts
cmd_tags() {
    ensure_db
    echo "TAG|COUNT"
    sqlite3 -separator '|' "$DB_FILE" <<'SQL'
WITH RECURSIVE split(tag, rest) AS (
    SELECT '', tags || ',' FROM notes WHERE archived_at IS NULL AND tags != ''
    UNION ALL
    SELECT
        TRIM(SUBSTR(rest, 1, INSTR(rest, ',') - 1)),
        SUBSTR(rest, INSTR(rest, ',') + 1)
    FROM split WHERE rest != ''
)
SELECT tag, COUNT(*) as cnt
FROM split
WHERE tag != ''
GROUP BY tag
ORDER BY cnt DESC, tag;
SQL
}

# List all projects with counts
cmd_projects() {
    ensure_db
    echo "PROJECT|COUNT"
    sqlite3 -separator '|' "$DB_FILE" <<'SQL'
SELECT COALESCE(project, 'global') as proj, COUNT(*) as cnt
FROM notes
WHERE archived_at IS NULL
GROUP BY project
ORDER BY cnt DESC;
SQL
}

# Archive a note
cmd_archive() {
    ensure_db
    if [ -z "$1" ]; then
        echo "Usage: zk archive ID"
        return 1
    fi

    local id="$1"
    validate_id "$id" || return 1

    if ! note_exists "$id"; then
        echo -e "${RED}Error: Note #$id not found${RESET}" >&2
        return 1
    fi

    sqlite3 "$DB_FILE" "UPDATE notes SET archived_at = CURRENT_TIMESTAMP WHERE id = $id;"
    echo "Archived note #$id"
}

# Unarchive a note
cmd_unarchive() {
    ensure_db
    if [ -z "$1" ]; then
        echo "Usage: zk unarchive ID"
        return 1
    fi

    local id="$1"
    validate_id "$id" || return 1

    if ! note_exists "$id"; then
        echo -e "${RED}Error: Note #$id not found${RESET}" >&2
        return 1
    fi

    sqlite3 "$DB_FILE" "UPDATE notes SET archived_at = NULL WHERE id = $id;"
    echo "Unarchived note #$id"
}

# Delete a note permanently
cmd_delete() {
    ensure_db
    if [ -z "$1" ]; then
        echo "Usage: zk delete ID"
        return 1
    fi

    local id="$1"
    validate_id "$id" || return 1

    if ! note_exists "$id"; then
        echo -e "${RED}Error: Note #$id not found${RESET}" >&2
        return 1
    fi

    # Clean up orphaned links in other notes using SQL (much faster for large databases)
    sqlite3 "$DB_FILE" <<SQL
-- Remove from start of list
UPDATE notes SET related_ids = SUBSTR(related_ids, LENGTH('$id') + 2)
WHERE related_ids LIKE '$id,%';

-- Remove from middle of list
UPDATE notes SET related_ids = REPLACE(related_ids, ',$id,', ',')
WHERE related_ids LIKE '%,$id,%';

-- Remove from end of list
UPDATE notes SET related_ids = SUBSTR(related_ids, 1, LENGTH(related_ids) - LENGTH('$id') - 1)
WHERE related_ids LIKE '%,$id';

-- Remove if only item
UPDATE notes SET related_ids = ''
WHERE related_ids = '$id';
SQL

    # Delete the note
    sqlite3 "$DB_FILE" "DELETE FROM notes WHERE id = $id;"
    echo "Deleted note #$id"
}

# Link two notes (bidirectional by default)
cmd_link() {
    ensure_db
    if [ $# -lt 2 ]; then
        echo "Usage: zk link ID1 ID2"
        return 1
    fi

    local id1="$1"
    local id2="$2"

    validate_id "$id1" || return 1
    validate_id "$id2" || return 1

    if [ "$id1" = "$id2" ]; then
        echo -e "${RED}Error: Cannot link a note to itself${RESET}" >&2
        return 1
    fi

    if ! note_exists "$id1"; then
        echo -e "${RED}Error: Note #$id1 not found${RESET}" >&2
        return 1
    fi

    if ! note_exists "$id2"; then
        echo -e "${RED}Error: Note #$id2 not found${RESET}" >&2
        return 1
    fi

    # Add bidirectional links
    add_related_id "$id1" "$id2"
    add_related_id "$id2" "$id1"

    echo "Linked notes #$id1 â†” #$id2"
}

# Unlink two notes (bidirectional)
cmd_unlink() {
    ensure_db
    if [ $# -lt 2 ]; then
        echo "Usage: zk unlink ID1 ID2"
        return 1
    fi

    local id1="$1"
    local id2="$2"

    validate_id "$id1" || return 1
    validate_id "$id2" || return 1

    if ! note_exists "$id1"; then
        echo -e "${RED}Error: Note #$id1 not found${RESET}" >&2
        return 1
    fi

    if ! note_exists "$id2"; then
        echo -e "${RED}Error: Note #$id2 not found${RESET}" >&2
        return 1
    fi

    # Remove bidirectional links
    remove_related_id "$id1" "$id2"
    remove_related_id "$id2" "$id1"

    echo "Unlinked notes #$id1 â†” #$id2"
}

# Show related notes
cmd_related() {
    ensure_db
    if [ $# -eq 0 ]; then
        echo "Usage: zk related ID [--full]"
        return 1
    fi

    local id="$1"
    local full_content=0

    if [ "${2:-}" = "--full" ] || [ "${2:-}" = "-f" ]; then
        full_content=1
    fi

    validate_id "$id" || return 1

    if ! note_exists "$id"; then
        echo -e "${RED}Error: Note #$id not found${RESET}" >&2
        return 1
    fi

    local related_ids
    related_ids=$(get_related_ids "$id")

    if [ -z "$related_ids" ]; then
        echo -e "${YELLOW}No related notes found for #$id${RESET}" >&2
        return 0
    fi

    if [ "$full_content" -eq 1 ]; then
        # Get full content of all related notes
        IFS=',' read -ra IDS <<< "$related_ids"
        for rid in "${IDS[@]}"; do
            if note_exists "$rid"; then
                cmd_get "$rid"
            fi
        done
    else
        # Show minimal list
        IFS=',' read -ra IDS <<< "$related_ids"
        for rid in "${IDS[@]}"; do
            if note_exists "$rid"; then
                sqlite3 -separator '|' "$DB_FILE" "SELECT id, title, tags, COALESCE(project, 'global') FROM notes WHERE id = $rid;"
            fi
        done
    fi
}

# Show stats
cmd_stats() {
    ensure_db
    sqlite3 "$DB_FILE" <<'SQL'
SELECT 'Total notes: ' || COUNT(*) FROM notes;
SELECT 'Active notes: ' || COUNT(*) FROM notes WHERE archived_at IS NULL;
SELECT 'Archived notes: ' || COUNT(*) FROM notes WHERE archived_at IS NOT NULL;
SELECT 'Projects: ' || COUNT(DISTINCT project) FROM notes WHERE project IS NOT NULL;
SELECT 'Unique tags: ' || (
    WITH RECURSIVE split(tag, rest) AS (
        SELECT '', tags || ',' FROM notes WHERE tags != ''
        UNION ALL
        SELECT TRIM(SUBSTR(rest, 1, INSTR(rest, ',') - 1)), SUBSTR(rest, INSTR(rest, ',') + 1)
        FROM split WHERE rest != ''
    )
    SELECT COUNT(DISTINCT tag) FROM split WHERE tag != ''
);
SQL
}

# Export to JSON
cmd_export() {
    ensure_db
    local outfile="${1:-/dev/stdout}"
    sqlite3 -json "$DB_FILE" "SELECT * FROM notes;" > "$outfile"
    [ "$outfile" != "/dev/stdout" ] && echo "Exported to $outfile"
}

# Import from JSON/JSONL
cmd_import() {
    ensure_db
    if [ -z "$1" ] || [ ! -f "$1" ]; then
        echo "Usage: zk import FILE.json|FILE.jsonl"
        return 1
    fi

    local file="$1"
    local count=0

    # Handle JSONL (one JSON object per line)
    if [[ "$file" == *.jsonl ]]; then
        while IFS= read -r line; do
            local title tags content project
            title=$(echo "$line" | jq -r '.title // empty')
            tags=$(echo "$line" | jq -r '.tags // empty')
            content=$(echo "$line" | jq -r '.content // empty')
            project=$(echo "$line" | jq -r '.project // empty')

            if [ -n "$title" ] && [ -n "$content" ]; then
                if [ -n "$project" ]; then
                    cmd_add -p "$project" "$title" "$tags" "$content" >/dev/null
                else
                    cmd_add "$title" "$tags" "$content" >/dev/null
                fi
                ((count++))
            fi
        done < "$file"
    else
        # Handle JSON array
        local len
        len=$(jq 'length' "$file")
        for ((i=0; i<len; i++)); do
            local title tags content project
            title=$(jq -r ".[$i].title // empty" "$file")
            tags=$(jq -r ".[$i].tags // empty" "$file")
            content=$(jq -r ".[$i].content // empty" "$file")
            project=$(jq -r ".[$i].project // empty" "$file")

            if [ -n "$title" ] && [ -n "$content" ]; then
                if [ -n "$project" ]; then
                    cmd_add -p "$project" "$title" "$tags" "$content" >/dev/null
                else
                    cmd_add "$title" "$tags" "$content" >/dev/null
                fi
                ((count++))
            fi
        done
    fi

    echo "Imported $count notes"
}

# Feed - output file content for analysis (Claude will process this)
cmd_feed() {
    if [ -z "$1" ] || [ ! -f "$1" ]; then
        echo "Usage: zk feed FILE"
        echo ""
        echo "This outputs the file content for Claude to analyze and suggest atomic notes."
        echo "Claude should then use 'zk add' commands to add the curated notes."
        return 1
    fi

    echo "=== FILE: $1 ==="
    echo "=== CONTENT START ==="
    cat "$1"
    echo ""
    echo "=== CONTENT END ==="
    echo ""
    echo "Analyze this content and extract atomic, searchable knowledge notes."
    echo "For each note, use: zk add \"title\" \"tags\" \"content\""
}

# Vacuum/optimize
cmd_vacuum() {
    ensure_db
    sqlite3 "$DB_FILE" "VACUUM; ANALYZE;"
    echo "Database optimized"
}

# Backup
cmd_backup() {
    ensure_db
    local backup="${1:-$ZK_DIR/brain_backup_$(date +%Y%m%d_%H%M%S).db}"
    cp "$DB_FILE" "$backup"
    echo "Backed up to $backup"
}

# Main dispatch
case "${1:-}" in
    init)
        init_db
        ;;
    search|s)
        shift
        cmd_search "$@"
        ;;
    get|g)
        shift
        cmd_get "$@"
        ;;
    add|a)
        shift
        cmd_add "$@"
        ;;
    update|u)
        shift
        cmd_update "$@"
        ;;
    list|ls|l)
        shift
        cmd_list "$@"
        ;;
    tags)
        cmd_tags
        ;;
    projects|proj)
        cmd_projects
        ;;
    archive)
        shift
        cmd_archive "$@"
        ;;
    unarchive)
        shift
        cmd_unarchive "$@"
        ;;
    delete|rm)
        shift
        cmd_delete "$@"
        ;;
    link)
        shift
        cmd_link "$@"
        ;;
    unlink)
        shift
        cmd_unlink "$@"
        ;;
    related)
        shift
        cmd_related "$@"
        ;;
    stats)
        cmd_stats
        ;;
    export)
        shift
        cmd_export "$@"
        ;;
    import)
        shift
        cmd_import "$@"
        ;;
    feed)
        shift
        cmd_feed "$@"
        ;;
    upgrade)
        upgrade_db
        ;;
    vacuum)
        cmd_vacuum
        ;;
    backup)
        shift
        cmd_backup "$@"
        ;;
    help|--help|-h|"")
        usage
        ;;
    *)
        echo "Unknown command: $1"
        echo "Run 'zk help' for usage"
        exit 1
        ;;
esac
